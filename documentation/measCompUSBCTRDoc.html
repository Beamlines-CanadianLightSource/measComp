<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>measComp</title>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type" />
</head>
<body>
  <div style="text-align: center">
    <h1>
      Driver for the Measurement Computing USB-CTR08</h1>
    <h2>
      June 10, 2014</h2>
    <h2>
      Mark Rivers</h2>
    <h2>
      University of Chicago</h2>
  </div>
  <h2>
    Table of Contents</h2>
  <ul>
    <li><a href="#Introduction">Introduction</a></li>
    <li><a href="#Configuration">Configuration</a></li>
    <li><a href="#Databases">Databases</a></li>
    <li><a href="#Wiring">Wiring</a></li>
    <li><a href="#Performance">Performance measurements</a> </li>
  </ul>
  <h2 id="Introduction" style="text-align: center">
    Introduction</h2>
  <p>
    This is an <a href="http://www.aps.anl.gov/epics">EPICS</a> driver for the <a href="http://www.mccdaq.com/usb-data-acquisition/USB-CTR08.aspx">
      USB-CTR04 and USB-CTR08</a> counter/timer module from <a href="http://www.mccdaq.com">
        Measurement Computing </a>The driver is written in C++, and consists of a class
    that inherits from <a href="http://www.aps.anl.gov/epics/modules/soft/asyn/R4-22/asynPortDriver.html">
      asynPortDriver</a>, which is part of the EPICS <a href="http://www.aps.anl.gov/epics/modules/soft/asyn">
        asyn</a> module.
  </p>
  <div style="text-align: center">
    <h3>
      Photo of USB-CTR08</h3>
    <img alt="USB-CTR08.jpg" src="USB-CTR08.jpg" /></div>
  <p>
    This module has the following features:</p>
  <ul>
    <li>Digital inputs/outputs
      <ul>
        <li>8 signals, individually programmable as inputs or outputs</li>
      </ul>
    </li>
    <li>Pulse generators. 4 pulse generators each with
      <ul>
        <li>48MHz clock, 32-bit registers</li>
        <li>Programmable period, width, number of pulses, polarity</li>
      </ul>
    </li>
    <li>Counters. 8 counters (USB-CTR08) or 4 counters (USB-CTR04)
      <ul>
        <li>48 MHz maximum count rate</li>
        <li>Support for EPICS scaler record (similar to Joerger VSC and SIS3820)</li>
        <li>Support for Multi-Channel Scaler (MCS) mode, similar to SIS3820.</li>
      </ul>
    </li>
  </ul>
  <h2 id="Configuration" style="text-align: center">
    Configuration</h2>
  <p>
    The following lines are needed in the EPICS startup script for the USBCTR.</p>
  <pre>
## Configure port driver
# USBCTRConfig(portName,       # The name to give to this asyn port driver
#              boardNum,       # The number of this board assigned by the Measurement Computing Instacal program 
#              numCounters)    # Number of counters to use
#              maxTimePoints)  # Maximum number of time points for MCS
USBCTRConfig("$(PORT)", 0, 2048)

#asynSetTraceMask $(PORT) 0 255

dbLoadTemplate("USBCTR.substitutions")

# This loads the scaler record and supporting records
dbLoadRecords("$(STD)/stdApp/Db/scaler.db", "P=USBCTR:, S=scaler1, DTYP=Asyn Scaler, OUT=@asyn(USBCTR), FREQ=10000000")

# This database provides the support for the MCS functions
dbLoadRecords("$(MEASCOMP)/measCompApp/Db/measCompMCS.template", "P=$(PREFIX), PORT=$(PORT)")

# Load either MCA or waveform records below
# The number of records loaded must be the same as MAX_COUNTERS defined above

# Load the MCA records
dbLoadRecords("$(MCA)/mcaApp/Db/simple_mca.db", "P=$(PREFIX), M=$(RNAME)1,  DTYP=asynMCA, INP=@asyn($(PORT) 0),  PREC=3, CHANS=$(MAX_POINTS)")
dbLoadRecords("$(MCA)/mcaApp/Db/simple_mca.db", "P=$(PREFIX), M=$(RNAME)2,  DTYP=asynMCA, INP=@asyn($(PORT) 1),  PREC=3, CHANS=$(MAX_POINTS)")
dbLoadRecords("$(MCA)/mcaApp/Db/simple_mca.db", "P=$(PREFIX), M=$(RNAME)3,  DTYP=asynMCA, INP=@asyn($(PORT) 2),  PREC=3, CHANS=$(MAX_POINTS)")
dbLoadRecords("$(MCA)/mcaApp/Db/simple_mca.db", "P=$(PREFIX), M=$(RNAME)4,  DTYP=asynMCA, INP=@asyn($(PORT) 3),  PREC=3, CHANS=$(MAX_POINTS)")
dbLoadRecords("$(MCA)/mcaApp/Db/simple_mca.db", "P=$(PREFIX), M=$(RNAME)5,  DTYP=asynMCA, INP=@asyn($(PORT) 4),  PREC=3, CHANS=$(MAX_POINTS)")
dbLoadRecords("$(MCA)/mcaApp/Db/simple_mca.db", "P=$(PREFIX), M=$(RNAME)6,  DTYP=asynMCA, INP=@asyn($(PORT) 5),  PREC=3, CHANS=$(MAX_POINTS)")
dbLoadRecords("$(MCA)/mcaApp/Db/simple_mca.db", "P=$(PREFIX), M=$(RNAME)7,  DTYP=asynMCA, INP=@asyn($(PORT) 6),  PREC=3, CHANS=$(MAX_POINTS)")
dbLoadRecords("$(MCA)/mcaApp/Db/simple_mca.db", "P=$(PREFIX), M=$(RNAME)8,  DTYP=asynMCA, INP=@asyn($(PORT) 7),  PREC=3, CHANS=$(MAX_POINTS)")

iocInit

seq(USBCTR_SNL, "P=$(PREFIX), R=$(RNAME), NUM_SIGNALS=$(MAX_COUNTERS), FIELD=$(FIELD)")
</pre>
  <p>
    The measComp module comes with an example iocBoot/iocMeasComp directory that contains
    example startup scripts and example substitutions files.</p>
  <h2 id="Databases" style="text-align: center">
    Databases</h2>
  <p>
    The following tables list the database template files that are used with the USB-CTR04/08.</p>
  <h3 style="text-align: center">
    Digital I/O Functions</h3>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <th>
          EPICS record name</th>
        <th>
          EPICS record type</th>
        <th>
          asyn interface</th>
        <th>
          drvInfo string</th>
        <th>
          Description</th>
      </tr>
      <tr>
        <td align="center" colspan="5">
          <b>measCompBinaryIn.template. This database is loaded once for each of the 8 binary
            I/O bits.</b></td>
      </tr>
      <tr>
        <td>
          $(P)$(R)</td>
        <td>
          bi</td>
        <td>
          asynUInt32Digital</td>
        <td>
          DIGITAL_INPUT</td>
        <td>
          Digital input value. The MASK parameter in the INP link defines which bit is used.
          The binary inputs are polled by the driver poller thread, so these records should
          have SCAN="I/O Intr".</td>
      </tr>
      <tr>
        <td align="center" colspan="5">
          <b>measCompLongIn.template. This database is loaded once for each module.</b></td>
      </tr>
      <tr>
        <td>
          $(P)$(R)</td>
        <td>
          longin</td>
        <td>
          asynUInt32Digital</td>
        <td>
          DIGITAL_INPUT</td>
        <td>
          Digital input value as a word, rather than individual bits. The MASK parameter in
          the INP link defines which bits are used. The binary inputs are polled by the driver
          poller thread, so this record should have SCAN="I/O Intr".</td>
      </tr>
      <tr>
        <td align="center" colspan="5">
          <b>measCompBinaryOut.template. This database is loaded once for each of the 8 binary
            I/O bits.</b></td>
      </tr>
      <tr>
        <td>
          $(P)$(R)</td>
        <td>
          bo</td>
        <td>
          asynUInt32Digital</td>
        <td>
          DIGITAL_OUTPUT</td>
        <td>
          Digital output value. The MASK parameter in the INP link defines which bit is used.
        </td>
      </tr>
      <tr>
        <td>
          $(P)$(R)_RBV</td>
        <td>
          bi</td>
        <td>
          asynUInt32Digital</td>
        <td>
          DIGITAL_OUTPUT</td>
        <td>
          Digital output value readback. The MASK parameter in the INP link defines which
          bit is used.</td>
      </tr>
      <tr>
        <td align="center" colspan="5">
          <b>measCompLongOut.template. This database is loaded once for each module.</b>
        </td>
      </tr>
      <tr>
        <td>
          $(P)$(R)</td>
        <td>
          longout</td>
        <td>
          asynUInt32Digital</td>
        <td>
          DIGITAL_OUTPUT</td>
        <td>
          Digital output value as a word, rather than individual bits. The MASK parameter
          in the INP link defines which bits are used.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)_RBV</td>
        <td>
          longin</td>
        <td>
          asynUInt32Digital</td>
        <td>
          DIGITAL_OUTPUT</td>
        <td>
          Digital output value readback as a word, rather than individual bits. The MASK parameter
          in the INP link defines which bits are used.</td>
      </tr>
      <tr>
        <td align="center" colspan="5">
          <b>measCompBinaryDir.template. This database is loaded once for each of the 8 binary
            I/O bits.</b></td>
      </tr>
      <tr>
        <td>
          $(P)$(R)</td>
        <td>
          bo</td>
        <td>
          asynUInt32Digital</td>
        <td>
          DIGITAL_DIRECTION</td>
        <td>
          Direction of this I/O line, "In" (0) or "Out" (1). The MASK parameter in the INP
          link defines which bit is used.</td>
      </tr>
    </tbody>
  </table>
  <h3 style="text-align: center">
    Pulse Generator Functions (these are called "timers" in Measurement Computing's
    documentation)</h3>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="5">
          <b>measCompPulseGen.template. This database is loaded once for each of the 4 pulse
            generators.</b></td>
      </tr>
      <tr>
        <th>
          EPICS record name</th>
        <th>
          EPICS record type</th>
        <th>
          asyn interface</th>
        <th>
          drvInfo string</th>
        <th>
          Description</th>
      </tr>
      <tr>
        <td>
          $(P)$(R)Run</td>
        <td>
          bo</td>
        <td>
          asynUInt32</td>
        <td>
          PULSE_RUN</td>
        <td>
          "Run" (1) starts the pulse generator, "Stop" (0) stops the pulse generator. Note
          that ideally this record should go back to 0 when the pulse generator is done, if
          it is outputting a finite number of pulses (see Count record). But unfortunately
          the Measurement Computing library does not have a way to query the status of the
          timer to see if it is done, so this is not possible.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Period<br />
          $(P)$(R)Period_RBV</td>
        <td>
          ao<br />
          ai</td>
        <td>
          asynFloat64</td>
        <td>
          PULSE_PERIOD</td>
        <td>
          Pulse period, in seconds. The time between pulses can be defined either with the
          Period or with the Frequency; whenever one record is changed the other is updated
          with the new calculated value. The minimum value is 20.83 ns (48 MHz) and the maximum
          value is 45.4 seconds. Period_RBV is the actual (readback) value which may differ
          from the requested value because the 96 MHz system clock constrains the period to
          be an integer multiple of 10.4166 ns.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Frequency
          <br />
          $(P)$(R)Frequency_RBV </td>
        <td>
          ao
          <br />
          calc</td>
        <td>
          N.A.</td>
        <td>
          N.A.</td>
        <td>
          Pulse frequency, in seconds. The Frequency calculates a new value of the Period,
          and sends the period value to the driver. The Frequency_RBV is calculated from the
          Period_RBV value.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Width
          <br />
          $(P)$(R)Width_RBV</td>
        <td>
          ao
          <br />
          ai</td>
        <td>
          asynFloat64</td>
        <td>
          PULSE_WIDTH</td>
        <td>
          Pulse width, in seconds. The allowed range is 10.42 ns to (Period-10.42 ns). Width_RBV
          is the actual (readback) value which may differ from the requested value because
          the 96 MHz system clock constrains the width to be an integer multiple of 10.4166
          ns.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Delay
          <br />
          $(P)$(R)Delay_RBV </td>
        <td>
          ao
          <br />
          ai</td>
        <td>
          asynFloat64</td>
        <td>
          PULSE_DELAY</td>
        <td>
          Initial pulse delay in seconds after Run is set to 1. Delay_RBV is the actual (readback)
          value which may differ from the requested value because the 96 MHz system clock
          constrains the width to be an integer multiple of 10.4166 ns.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Count</td>
        <td>
          longout</td>
        <td>
          asynInt32</td>
        <td>
          PULSE_COUNT</td>
        <td>
          Number of pulses to output. If the Count is 0 then the pulse generator runs continuously
          until Run is set to 0.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)IdleState</td>
        <td>
          bo</td>
        <td>
          asynInt32</td>
        <td>
          PULSE_IDLE_STATE</td>
        <td>
          The idle state of the pulse output line, "Low" (0) or "High" (1). This determines
          the polarity of the pulse, i.e. positive going or negative going.</td>
      </tr>
    </tbody>
  </table>
  <h3 style="text-align: center">
    Scaler Record Support</h3>
  <p>
    The USBCTR driver provides support for the EPICS scaler record via the devScalerAsyn.c
    device support in the <a href="http://www.aps.anl.gov/bcda/synApps">synApps</a>
    <a href="http://www.aps.anl.gov/bcda/synApps/std/std.html">std</a> module. It supports
    up to 8 channels. The following wiring connections must be made in order for counters
    1-8 to be stopped by counter 0, as is normally desired.</p>
  <ul>
    <li>Counter 0 Output must be connected to the Gate input on Counters 1-7.</li>
  </ul>
  <p>
    The .PR1 preset is performed in hardware via the Counter 0 Output and Counters 1-7
    gates. Counters 1-7 can also be set as preset counters, and the scaler record will
    stop counting when any of these preset values (.PR2-.PR8) are exceeded. However,
    unlike the .PR1 preset, these presets are done in software in the driver polling
    routine. This polling routine runs at 100 Hz, and whenever a preset is exceeded
    counting is stopped. Each of the counters will have counted for exactly the same
    amount of time, but the actual count time could be up to 0.01 seconds longer than
    the time when the preset was reached.</p>
  <p>
    Counter 0 is normally used as the preset counter, and is connected to a fixed frequency
    source. Any of the on-board pulse generators can be used to provide this frequency
    source, for example. It is important to set the scaler record .FREQ field to be
    the value of the Frequency_RBV of the pulse generator (the actual frequency) and
    not the Frequency field (the requested frequency) since these can differ, particularly
    at frequencies &gt;1 MHz.</p>
  <h3 style="text-align: center">
    Multi-Channel Scaler (MCS) Support</h3>
  <p>
    The USBCTR driver provides multi-channel scaler support very similar to the SIS3820
    driver in the synApps mca module. The support has the following properties:</p>
  <ul>
    <li>The number of counters being used in MCS mode can be selected with the FirstCounter
      and LastCounter records. Each can range from 0 to 7; LastCounter must be greater
      than or equal to FirstCounter. The number of active counters can thus range from
      1 to 8.</li>
    <li>The minimum dwell time, either with internal or external channel advance, is 250
      ns times the number of active counters. For example if only 2 counters are being
      used, the clock input on Counter 0 and a signal on Counter 1, then the minimum dwell
      time is 500 ns. If all 8 counters are being used then the minimum dwell time is
      2 microseconds.</li>
    <li>Either MCS or waveform records can be used to hold the time series data.</li>
    <li>There is no limitation on the length of the waveform or mca records, only the
      size of system RAM.</li>
    <li>An external channel advance signal can be used directly by connecting it to the
      External Clock Input (CLKI)on the USB-CTR module. The minimum dwell time (period)
      of this signal is described above.</li>
    <li>An external channel advance can be "prescaled" (frequency divided by N) by connecting
      it to a counter input that is outside the range of FirstCounter to LastCounter.
      This counter is assigned to the PrescaleCounter record. The Counter Output of the
      PrescaleCounter must be connected to the External Clock Input on the USB-CTR module.</li>
  </ul>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="5">
          <b>measCompMCS.template. This database is loaded once per module.</b></td>
      </tr>
      <tr>
        <th>
          EPICS record name</th>
        <th>
          EPICS record type</th>
        <th>
          asyn interface</th>
        <th>
          drvInfo string</th>
        <th>
          Description</th>
      </tr>
      <tr>
        <td>
          $(P)$(R)SNL_Connected</td>
        <td>
          bi</td>
        <td>
          N.A.</td>
        <td>
          N.A.</td>
        <td>
          This record is 1 ("Connected") if all PVs have connected in the USBCTR_SNL State Notation Language program.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)EraseAll</td>
        <td>
          bo</td>
        <td>
          asynInt32</td>
        <td>
          MCA_ERASE</td>
        <td>
          Erases the MCS data, setting the arrays and the elapsed times to 0.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)EraseStart</td>
        <td>
          bo</td>
        <td>
          asynInt32</td>
        <td>
          MCA_ERASE</td>
        <td>
          Erases the MCS data and then starts MCS acquisition by forward linking to StartAll.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)StartAll</td>
        <td>
          bo</td>
        <td>
          asynInt32</td>
        <td>
          MCA_START_ACQUIRE</td>
        <td>
          Starts MCS acquisition.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Acquiring</td>
        <td>
          busy</td>
        <td>
          N.A.</td>
        <td>
          N.A.</td>
        <td>
          Busy record is 1 ("Acquiring") when MCS is acquiring and 0 ("Done") when done..</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)StopAll</td>
        <td>
          bo</td>
        <td>
          asynInt32</td>
        <td>
          MCA_STOP_ACQUIRE</td>
        <td>
          Stops MCS acquisition.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)PresetReal</td>
        <td>
          ao</td>
        <td>
          asynFloat64</td>
        <td>
          MCA_PRESET_REAL</td>
        <td>
          Preset real time. If non-zero acquisition will stop after this time.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)ElapsedReal</td>
        <td>
          ai</td>
        <td>
          asynFloat64</td>
        <td>
          MCA_ELAPSED_REAL</td>
        <td>
          Elapsed real time.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)ReadAll</td>
        <td>
          bo</td>
        <td>
          N.A</td>
        <td>
          N.A.</td>
        <td>
          Forces a read of all of the array data.  This is done by the SNL program.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)NuseAll</td>
        <td>
          longout</td>
        <td>
          asynInt32</td>
        <td>
          MCA_NUM_CHANNELS</td>
        <td>
          The number of time points to acquire.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)CurrentChannel</td>
        <td>
          longin</td>
        <td>
          asynInt32</td>
        <td>
          MCS_CURRENT_POINT</td>
        <td>
          The current time point in the acquisition.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Dwell</td>
        <td>
          ao</td>
        <td>
          asynFloat64</td>
        <td>
          MCA_DWELL_TIME</td>
        <td>
          The dwell time per time point in internal channel advance mode.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)ChannelAdvance</td>
        <td>
          bo</td>
        <td>
          asynInt32</td>
        <td>
          MCA_CH_ADV_SOURCE</td>
        <td>
          The channel advance source. 0="Internal" uses DWELL record, 1="External" uses 
          External Clock Input on USB-CTR module.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Prescale</td>
        <td>
          bo</td>
        <td>
          asynInt32</td>
        <td>
          MCA_PRESCALE</td>
        <td>
          The prescale factor for the external channel advance source.  
          To use Prescale the external clock must be input to the counter channel selected by PrescaleCounter,
          and the output of the PrescaleCounter counter channel must be connected to the External Clock Input.
          Note that due to hardware limitations Prescale must be &gt; 1.  For no prescaling the external
          channel advance source must be connected directly to the External Clock Input.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)FirstCounter</td>
        <td>
          mbbo</td>
        <td>
          asynInt32</td>
        <td>
          MCS_FIRST_COUNTER</td>
        <td>
          The first counter channel to use in MCS mode. 0="CNTR0" ... 7="CNTR7".</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)LastCounter</td>
        <td>
          mbbo</td>
        <td>
          asynInt32</td>
        <td>
          MCS_LAST_COUNTER</td>
        <td>
          The last counter channel to use in MCS mode. 0="CNTR0" ... 7="CNTR7". Must be &gt;= FirstCounter.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)PrescaleCounter</td>
        <td>
          mbbo</td>
        <td>
          asynInt32</td>
        <td>
          MCS_PRESCALE_COUNTER</td>
        <td>
          The counter channel to use for prescaling the external channel advance in MCS mode. 0="CNTR0" ... 7="CNTR7".
          This channel must be either &lt;FirstChannel or &gt;LastChannel.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)MaxChannels</td>
        <td>
          longin</td>
        <td>
          asynInt32</td>
        <td>
          MCS_MAX_POINTS</td>
        <td>
          The maximum number of points in MCS arrays.  This is determined by the value of the MAX_POINTS macro
          parameter when loading the MCA or waveform records.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Model</td>
        <td>
          mbbi</td>
        <td>
          asynInt32</td>
        <td>
          MODEL</td>
        <td>
          The model number of the counter module. 0="USB-CRT08", 1="USB-CTR04".</td>
      </tr>
    </tbody>
  </table>
    <h3 style="text-align: center">
      Trigger Functions</h3>
  </div>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="5">
          <b>measCompTrigger.template. This database is loaded once per module.</b></td>
      </tr>
      <tr>
        <th>
          EPICS record name</th>
        <th>
          EPICS record type</th>
        <th>
          asyn interface</th>
        <th>
          drvInfo string</th>
        <th>
          Description</th>
      </tr>
      <tr>
        <td>
          $(P)$(R)Mode</td>
        <td>
          mbbo</td>
        <td>
          asynInt32</td>
        <td>
          TRIGGER_MODE</td>
        <td>
          The mode of the external trigger input. Choices are "Positive edge", "Negative edge",
          "High", and "Low".</td>
      </tr>
    </tbody>
  </table>
  <h3 style="text-align: center">
    medm screens</h3>
  <p>
    The following is the main medm screen for controlling the USB-CTR04/08.</p>
  <div style="text-align: center">
    <h3>
      USBCTR.adl</h3>
    <img alt="USBCTR.png" src="USBCTR.png" /></div>
  <p>
    The following is the medm screen for the EPICS scaler record using the USB-CTR04/08.</p>
  <div style="text-align: center">
    <h3>
      scaler_full.adl</h3>
    <img alt="USBCTR_scaler.png" src="USBCTR_scaler.png" /></div>
  <p>
    The following is the medm screen for controlling the MCS mode of the USB-CTR04/08.</p>
  <div style="text-align: center">
    <h3>
      USBCTR_MCS.adl</h3>
    <img alt="USBCTR_MCS.png" src="USBCTR_MCS.png" /></div>
  <div style="text-align: center">
    <h3>
      USBCTR_MCS_8_plots.adl</h3>
    <img alt="USBCTR_MCS_plots.png" src="USBCTR_MCS_plots.png" />
  <h2 id="Wiring" style="text-align: center">
    Wiring to BCDA BC-020 LEMO Breakout Panels</h2>
  <p>
    The following photo shows the BCDA BC-020 LEMO breakout panels wired to the USB-1608GX-2A0.
    These are the lower 2 BC-020 panels in this photo. A BC-020 with a BC-026 daughter
    card is used for the analog signals (lower left), and a BC-020 with a BC-087 daughter
    card for the digital signals (lower right).</p>
  <div style="text-align: center">
    <h3>
      BC-020 LEMO breakout panels</h3>
    <img alt="measCompBC-020.jpg" src="measCompBC-020.jpg" /></div>
  <h3 id="USB-1608GX-2A0_wiring">
    USB-1608GX-2A0 Wiring to Two BCDA BC-020 LEMO Breakout Panels</h3>
  <pre>      Digital I/O using BC-087 daughter card

50-pin ribbon      USB-1608GX      BC-020   EPICS Function
connector pin    screw terminal   connector
 1                DIO0               J1     Digital I/O bit 0 
 2                DIO1               J2     Digital I/O bit 1
 3                DIO2               J3     Digital I/O bit 2
 4                DIO3               J4     Digital I/O bit 3
 5                DIO4               J5     Digital I/O bit 4
 6                DIO5               J6     Digital I/O bit 5
 7                DIO6               J7     Digital I/O bit 6
 8                DIO7               J8     Digital I/O bit 7
 9                 TMR               J9     Pulse generator output
10                 GND              J10     Grounded to avoid cross-talk
11                CTR0              J11     Counter 1 input
12                 GND              J12     Grounded to avoid cross-talk
13                CTR1              J13     Counter 2 input
14                 GND              J14     Grounded to avoid cross-talk
15                TRIG              J15     Trigger input for waveform generator and waveform digitizer
16                 GND              J16     Grounded to avoid cross-talk
17               A0CK0              J17     Waveform generator clock out
18                 GND              J18     Grounded to avoid cross-talk
19               A0CKI              J19     Waveform generator clock in
20                 GND              J20     Grounded to avoid cross-talk
21               AICK0              J21     Waveform digitizer clock out
22                 GND              J16     Grounded to avoid cross-talk
23               AICKI              J17     Waveform digitzer clock in
50                 GND           J1-J32     LEMO connectors outer shells

 
         Analog I/O using BC-026 daughter card

50-pin ribbon      USB-1608GX      BC-020   EPICS Function
connector pin    screw terminal   connector
 1                CH0H               J1     Analog input 1 +
 2                CH0L               J1     Analog input 1 -
 3                AGND              N.C     Analog ground
 4                CH1H               J2     Analog input 2 +
 5                CH1L               J2     Analog input 2 -
 6                AGND              N.C     Analog ground
 7                CH2H               J3     Analog input 3 +
 8                CH2L               J3     Analog input 3 -
 9                AGND              N.C     Analog ground
10                CH3H               J4     Analog input 4 +
11                CH3L               J4     Analog input 4 -
12                AGND              N.C     Analog ground
13                CH4H               J5     Analog input 5 +
14                CH4L               J5     Analog input 5 -
15                AGND              N.C     Analog ground
16                CH5H               J6     Analog input 6 +
17                CH5L               J6     Analog input 6 -
18                AGND              N.C     Analog ground
19                CH6H               J7     Analog input 7 +
20                CH6L               J7     Analog input 7 -
21                AGND              N.C     Analog ground
22                CH7H               J8     Analog input 8 +
23                CH7L               J8     Analog input 8 -
24                AGND              N.C     Analog ground
25               AOUT0               J9     Analog output 1
26                AGND               J9     Analog ground
27                AGND              N.C     Analog ground
28               AOUT1              J10     Analog output 1
29                AGND              J10     Analog ground

Note: the "Analog input N +" lines are connected to the Lemo center pin, 
and the "Analog input N -" lines are connected to the Lemo shell.
</pre>
  <h2 id="Performance" style="text-align: center">
    Performance measurements</h2>
  <hr />
  <address>
    Suggestions and Comments to:
    <br />
    <a href="mailto:rivers@cars.uchicago.edu">Mark Rivers </a>: (rivers@cars.uchicago.edu)
    <br />
  </address>
</body>
</html>
